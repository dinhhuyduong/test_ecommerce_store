{"ast":null,"code":"import _defineProperty from \"D:/EP26/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"D:/EP26/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"D:/EP26/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/EP26/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.error.to-string.js\";\nimport \"core-js/modules/es.date.to-string.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.array.reduce.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport deepmerge from 'deepmerge';\n/**\r\n * Created by championswimmer on 22/07/17.\r\n */\n\nvar MockStorage; // @ts-ignore\n\n{\n  MockStorage = /*#__PURE__*/function () {\n    function MockStorage() {\n      _classCallCheck(this, MockStorage);\n    }\n\n    _createClass(MockStorage, [{\n      key: \"length\",\n      get: function get() {\n        return Object.keys(this).length;\n      }\n    }, {\n      key: \"key\",\n      value: function key(index) {\n        return Object.keys(this)[index];\n      }\n    }, {\n      key: \"setItem\",\n      value: function setItem(key, data) {\n        this[key] = data.toString();\n      }\n    }, {\n      key: \"getItem\",\n      value: function getItem(key) {\n        return this[key];\n      }\n    }, {\n      key: \"removeItem\",\n      value: function removeItem(key) {\n        delete this[key];\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        for (var _i = 0, _Object$keys = Object.keys(this); _i < _Object$keys.length; _i++) {\n          var key = _Object$keys[_i];\n          delete this[key];\n        }\n      }\n    }]);\n\n    return MockStorage;\n  }();\n} // tslint:disable: variable-name\n\nvar SimplePromiseQueue = /*#__PURE__*/function () {\n  function SimplePromiseQueue() {\n    _classCallCheck(this, SimplePromiseQueue);\n\n    this._queue = [];\n    this._flushing = false;\n  }\n\n  _createClass(SimplePromiseQueue, [{\n    key: \"enqueue\",\n    value: function enqueue(promise) {\n      this._queue.push(promise);\n\n      if (!this._flushing) {\n        return this.flushQueue();\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"flushQueue\",\n    value: function flushQueue() {\n      var _this = this;\n\n      this._flushing = true;\n\n      var chain = function chain() {\n        var nextTask = _this._queue.shift();\n\n        if (nextTask) {\n          return nextTask.then(chain);\n        } else {\n          _this._flushing = false;\n        }\n      };\n\n      return Promise.resolve(chain());\n    }\n  }]);\n\n  return SimplePromiseQueue;\n}();\n\nvar options = {\n  replaceArrays: {\n    arrayMerge: function arrayMerge(destinationArray, sourceArray, options) {\n      return sourceArray;\n    }\n  },\n  concatArrays: {\n    arrayMerge: function arrayMerge(target, source, options) {\n      return target.concat.apply(target, _toConsumableArray(source));\n    }\n  }\n};\n\nfunction merge(into, from, mergeOption) {\n  return deepmerge(into, from, options[mergeOption]);\n}\n\nvar FlattedJSON = JSON;\n/**\r\n * A class that implements the vuex persistence.\r\n * @type S type of the 'state' inside the store (default: any)\r\n */\n\nvar VuexPersistence = /*#__PURE__*/_createClass(\n/**\r\n * Create a {@link VuexPersistence} object.\r\n * Use the <code>plugin</code> function of this class as a\r\n * Vuex plugin.\r\n * @param {PersistOptions} options\r\n */\nfunction VuexPersistence(options) {\n  var _this2 = this;\n\n  _classCallCheck(this, VuexPersistence);\n\n  // tslint:disable-next-line:variable-name\n  this._mutex = new SimplePromiseQueue();\n  /**\r\n   * Creates a subscriber on the store. automatically is used\r\n   * when this is used a vuex plugin. Not for manual usage.\r\n   * @param store\r\n   */\n\n  this.subscriber = function (store) {\n    return function (handler) {\n      return store.subscribe(handler);\n    };\n  };\n\n  if (typeof options === 'undefined') options = {};\n  this.key = options.key != null ? options.key : 'vuex';\n  this.subscribed = false;\n  this.supportCircular = options.supportCircular || false;\n\n  if (this.supportCircular) {\n    FlattedJSON = require('flatted');\n  }\n\n  this.mergeOption = options.mergeOption || 'replaceArrays';\n  var localStorageLitmus = true;\n\n  try {\n    window.localStorage.getItem('');\n  } catch (err) {\n    localStorageLitmus = false;\n  }\n  /**\r\n   * 1. First, prefer storage sent in optinos\r\n   * 2. Otherwise, use window.localStorage if available\r\n   * 3. Finally, try to use MockStorage\r\n   * 4. None of above? Well we gotta fail.\r\n   */\n\n\n  if (options.storage) {\n    this.storage = options.storage;\n  } else if (localStorageLitmus) {\n    this.storage = window.localStorage;\n  } else if (MockStorage) {\n    this.storage = new MockStorage();\n  } else {\n    throw new Error(\"Neither 'window' is defined, nor 'MockStorage' is available\");\n  }\n  /**\r\n   * How this works is -\r\n   *  1. If there is options.reducer function, we use that, if not;\r\n   *  2. We check options.modules;\r\n   *    1. If there is no options.modules array, we use entire state in reducer\r\n   *    2. Otherwise, we create a reducer that merges all those state modules that are\r\n   *        defined in the options.modules[] array\r\n   * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\r\n   */\n\n\n  this.reducer = options.reducer != null ? options.reducer : options.modules == null ? function (state) {\n    return state;\n  } : function (state) {\n    return options.modules.reduce(function (a, i) {\n      return merge(a, _defineProperty({}, i, state[i]), _this2.mergeOption);\n    }, {\n      /* start empty accumulator*/\n    });\n  };\n\n  this.filter = options.filter || function (mutation) {\n    return true;\n  };\n\n  this.strictMode = options.strictMode || false;\n\n  this.RESTORE_MUTATION = function RESTORE_MUTATION(state, savedState) {\n    var mergedState = merge(state, savedState || {}, this.mergeOption);\n\n    for (var _i2 = 0, _Object$keys2 = Object.keys(mergedState); _i2 < _Object$keys2.length; _i2++) {\n      var propertyName = _Object$keys2[_i2];\n\n      this._vm.$set(state, propertyName, mergedState[propertyName]);\n    }\n  };\n\n  this.asyncStorage = options.asyncStorage || false;\n\n  if (this.asyncStorage) {\n    /**\r\n     * Async {@link #VuexPersistence.restoreState} implementation\r\n     * @type {((key: string, storage?: Storage) =>\r\n     *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\r\n     */\n    this.restoreState = options.restoreState != null ? options.restoreState : function (key, storage) {\n      return storage.getItem(key).then(function (value) {\n        return typeof value === 'string' // If string, parse, or else, just return\n        ? _this2.supportCircular ? FlattedJSON.parse(value || '{}') : JSON.parse(value || '{}') : value || {};\n      });\n    };\n    /**\r\n     * Async {@link #VuexPersistence.saveState} implementation\r\n     * @type {((key: string, state: {}, storage?: Storage) =>\r\n     *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n     */\n\n    this.saveState = options.saveState != null ? options.saveState : function (key, state, storage) {\n      return storage.setItem(key, // Second argument is state _object_ if asyc storage, stringified otherwise\n      // do not stringify the state if the storage type is async\n      _this2.asyncStorage ? merge({}, state || {}, _this2.mergeOption) : _this2.supportCircular ? FlattedJSON.stringify(state) : JSON.stringify(state));\n    };\n    /**\r\n     * Async version of plugin\r\n     * @param {Store<S>} store\r\n     */\n\n    this.plugin = function (store) {\n      /**\r\n       * For async stores, we're capturing the Promise returned\r\n       * by the `restoreState()` function in a `restored` property\r\n       * on the store itself. This would allow app developers to\r\n       * determine when and if the store's state has indeed been\r\n       * refreshed. This approach was suggested by GitHub user @hotdogee.\r\n       * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\r\n       * @since 2.1.0\r\n       */\n      store.restored = _this2.restoreState(_this2.key, _this2.storage).then(function (savedState) {\n        /**\r\n         * If in strict mode, do only via mutation\r\n         */\n        if (_this2.strictMode) {\n          store.commit('RESTORE_MUTATION', savedState);\n        } else {\n          store.replaceState(merge(store.state, savedState || {}, _this2.mergeOption));\n        }\n\n        _this2.subscriber(store)(function (mutation, state) {\n          if (_this2.filter(mutation)) {\n            _this2._mutex.enqueue(_this2.saveState(_this2.key, _this2.reducer(state), _this2.storage));\n          }\n        });\n\n        _this2.subscribed = true;\n      });\n    };\n  } else {\n    /**\r\n     * Sync {@link #VuexPersistence.restoreState} implementation\r\n     * @type {((key: string, storage?: Storage) =>\r\n     *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\r\n     */\n    this.restoreState = options.restoreState != null ? options.restoreState : function (key, storage) {\n      var value = storage.getItem(key);\n\n      if (typeof value === 'string') {\n        // If string, parse, or else, just return\n        return _this2.supportCircular ? FlattedJSON.parse(value || '{}') : JSON.parse(value || '{}');\n      } else {\n        return value || {};\n      }\n    };\n    /**\r\n     * Sync {@link #VuexPersistence.saveState} implementation\r\n     * @type {((key: string, state: {}, storage?: Storage) =>\r\n     *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n     */\n\n    this.saveState = options.saveState != null ? options.saveState : function (key, state, storage) {\n      return storage.setItem(key, // Second argument is state _object_ if localforage, stringified otherwise\n      _this2.supportCircular ? FlattedJSON.stringify(state) : JSON.stringify(state));\n    };\n    /**\r\n     * Sync version of plugin\r\n     * @param {Store<S>} store\r\n     */\n\n    this.plugin = function (store) {\n      var savedState = _this2.restoreState(_this2.key, _this2.storage);\n\n      if (_this2.strictMode) {\n        store.commit('RESTORE_MUTATION', savedState);\n      } else {\n        store.replaceState(merge(store.state, savedState || {}, _this2.mergeOption));\n      }\n\n      _this2.subscriber(store)(function (mutation, state) {\n        if (_this2.filter(mutation)) {\n          _this2.saveState(_this2.key, _this2.reducer(state), _this2.storage);\n        }\n      });\n\n      _this2.subscribed = true;\n    };\n  }\n});\n\nexport default VuexPersistence;\nexport { MockStorage, VuexPersistence };","map":{"version":3,"mappings":"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","names":["MockStorage","Object","keys","length","index","key","data","toString","SimplePromiseQueue","promise","_queue","push","_flushing","flushQueue","Promise","resolve","chain","nextTask","shift","then","options","replaceArrays","arrayMerge","destinationArray","sourceArray","concatArrays","target","source","concat","merge","into","from","mergeOption","deepmerge","FlattedJSON","JSON","VuexPersistence","store","handler","subscribe","subscribed","supportCircular","require","localStorageLitmus","window","localStorage","getItem","err","storage","Error","reducer","modules","state","reduce","a","i","filter","mutation","strictMode","RESTORE_MUTATION","savedState","mergedState","propertyName","_vm","$set","asyncStorage","restoreState","value","parse","saveState","setItem","stringify","plugin","restored","commit","replaceState","subscriber","_mutex","enqueue"],"sources":["../../src/MockStorage.ts","../../src/SimplePromiseQueue.ts","../../src/utils.ts","../../src/index.ts"],"sourcesContent":["/**\n * Created by championswimmer on 22/07/17.\n */\nlet MockStorage: typeof Storage | undefined\n\n// @ts-ignore\nif (process.env.MODULE_FORMAT !== 'umd') {\n  MockStorage = class implements Storage {\n    [index: number]: string;\n    [key: string]: any;\n\n    public get length(): number {\n      return Object.keys(this).length\n    }\n\n    public key(index: number): string | any {\n      return Object.keys(this)[index]\n    }\n\n    public setItem(key: string, data: any): void {\n      this[key] = data.toString()\n    }\n    public getItem(key: string): string {\n      return this[key]\n    }\n    public removeItem(key: string): void {\n      delete this[key]\n    }\n    public clear(): void {\n      for (let key of Object.keys(this)) {\n        delete this[key]\n      }\n    }\n  }\n}\n\nexport { MockStorage }\n","// tslint:disable: variable-name\nexport default class SimplePromiseQueue {\n  private readonly _queue: Array<Promise<void>> = []\n  private _flushing = false\n\n  public enqueue(promise: Promise<void>) {\n    this._queue.push(promise)\n    if (!this._flushing) { return this.flushQueue() }\n    return Promise.resolve()\n  }\n\n  private flushQueue() {\n    this._flushing = true\n\n    const chain = (): Promise<void> | void => {\n      const nextTask = this._queue.shift()\n      if (nextTask) {\n        return nextTask.then(chain)\n      } else {\n        this._flushing = false\n      }\n    }\n    return Promise.resolve(chain())\n  }\n}\n","import deepmerge from 'deepmerge'\n\nexport type MergeOptionType = 'replaceArrays' | 'concatArrays'\n\nconst options: {[k in MergeOptionType]: deepmerge.Options} = {\n  replaceArrays: {\n    arrayMerge: (destinationArray, sourceArray, options) => sourceArray\n  },\n  concatArrays: {\n    arrayMerge: (target, source, options) => target.concat(...source)\n  }\n}\n\nconst defaultMergeOptions: deepmerge.Options = {\n  // replacing arrays\n  \n}\n\nexport function merge<I, F>(into: Partial<I>, from: Partial<F>, mergeOption: MergeOptionType): I & F & {} {\n  return deepmerge(into, from, options[mergeOption])\n}\n","/**\n * Created by championswimmer on 18/07/17.\n */\nimport { Mutation, MutationPayload, Payload, Plugin, Store } from 'vuex'\nimport { AsyncStorage } from './AsyncStorage'\nimport { MockStorage } from './MockStorage'\nimport { PersistOptions } from './PersistOptions'\nimport SimplePromiseQueue from './SimplePromiseQueue'\nimport { merge, MergeOptionType } from './utils'\n\nlet FlattedJSON = JSON\n\n/**\n * A class that implements the vuex persistence.\n * @type S type of the 'state' inside the store (default: any)\n */\nexport class VuexPersistence<S> implements PersistOptions<S> {\n  public asyncStorage: boolean\n  public storage: Storage | AsyncStorage | undefined\n  public restoreState: (key: string, storage?: AsyncStorage | Storage) => Promise<S> | S\n  public saveState: (key: string, state: {}, storage?: AsyncStorage | Storage) => Promise<void> | void\n  public reducer: (state: S) => Partial<S>\n  public key: string\n  public filter: (mutation: Payload) => boolean\n  public modules: string[]\n  public strictMode: boolean\n  public supportCircular: boolean\n  public mergeOption: MergeOptionType\n\n  /**\n   * The plugin function that can be used inside a vuex store.\n   */\n  public plugin: Plugin<S>\n  /**\n   * A mutation that can be used to restore state\n   * Helpful if we are running in strict mode\n   */\n  public RESTORE_MUTATION: Mutation<S>\n  public subscribed: boolean\n\n  // tslint:disable-next-line:variable-name\n  private _mutex = new SimplePromiseQueue()\n\n  /**\n   * Create a {@link VuexPersistence} object.\n   * Use the <code>plugin</code> function of this class as a\n   * Vuex plugin.\n   * @param {PersistOptions} options\n   */\n  public constructor(options?: PersistOptions<S>) {\n    if (typeof options === 'undefined') options = {} as PersistOptions<S>\n    this.key = ((options.key != null) ? options.key : 'vuex')\n\n    this.subscribed = false\n    this.supportCircular = options.supportCircular || false\n    if (this.supportCircular) {\n      FlattedJSON = require('flatted')\n    }\n    this.mergeOption = options.mergeOption || 'replaceArrays'\n\n    let localStorageLitmus = true\n\n    try {\n      window.localStorage.getItem('')\n    } catch (err) {\n      localStorageLitmus = false\n    }\n\n    /**\n     * 1. First, prefer storage sent in optinos\n     * 2. Otherwise, use window.localStorage if available\n     * 3. Finally, try to use MockStorage\n     * 4. None of above? Well we gotta fail.\n     */\n    if (options.storage) { this.storage = options.storage }\n    else if (localStorageLitmus) { this.storage = window.localStorage }\n    else if (MockStorage) { this.storage = new MockStorage() }\n    else { throw new Error(\"Neither 'window' is defined, nor 'MockStorage' is available\") }\n\n    /**\n     * How this works is -\n     *  1. If there is options.reducer function, we use that, if not;\n     *  2. We check options.modules;\n     *    1. If there is no options.modules array, we use entire state in reducer\n     *    2. Otherwise, we create a reducer that merges all those state modules that are\n     *        defined in the options.modules[] array\n     * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\n     */\n    this.reducer = (\n      (options.reducer != null)\n        ? options.reducer\n        : (\n          (options.modules == null)\n            ? ((state: S) => state)\n            : (\n              (state: any) =>\n                (options!.modules as string[]).reduce((a, i) =>\n                  merge(a, { [i]: state[i] }, this.mergeOption), {/* start empty accumulator*/ })\n            )\n        )\n    )\n\n    this.filter = options.filter || ((mutation) => true)\n\n    this.strictMode = options.strictMode || false\n\n    this.RESTORE_MUTATION = function RESTORE_MUTATION(state: S, savedState: any) {\n      const mergedState = merge(state, savedState || {}, this.mergeOption)\n      for (const propertyName of Object.keys(mergedState as {})) {\n        (this as any)._vm.$set(state, propertyName, (mergedState as any)[propertyName])\n      }\n    }\n\n    this.asyncStorage = options.asyncStorage || false\n\n    if (this.asyncStorage) {\n\n      /**\n       * Async {@link #VuexPersistence.restoreState} implementation\n       * @type {((key: string, storage?: Storage) =>\n       *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\n       */\n      this.restoreState = (\n        (options.restoreState != null)\n          ? options.restoreState\n          : ((key: string, storage: AsyncStorage) =>\n            (storage).getItem(key)\n              .then((value) =>\n                typeof value === 'string' // If string, parse, or else, just return\n                  ? (\n                    this.supportCircular\n                      ? FlattedJSON.parse(value || '{}')\n                      : JSON.parse(value || '{}')\n                  )\n                  : (value || {})\n              )\n          )\n      )\n\n      /**\n       * Async {@link #VuexPersistence.saveState} implementation\n       * @type {((key: string, state: {}, storage?: Storage) =>\n       *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\n       */\n      this.saveState = (\n        (options.saveState != null)\n          ? options.saveState\n          : ((key: string, state: {}, storage: AsyncStorage) =>\n            (storage).setItem(\n              key, // Second argument is state _object_ if asyc storage, stringified otherwise\n              // do not stringify the state if the storage type is async\n              (this.asyncStorage\n                ? merge({}, state || {}, this.mergeOption)\n                : (\n                  this.supportCircular\n                    ? FlattedJSON.stringify(state) as any\n                    : JSON.stringify(state) as any\n                )\n              )\n            )\n          )\n      )\n\n      /**\n       * Async version of plugin\n       * @param {Store<S>} store\n       */\n      this.plugin = (store: Store<S>) => {\n        /**\n         * For async stores, we're capturing the Promise returned\n         * by the `restoreState()` function in a `restored` property\n         * on the store itself. This would allow app developers to\n         * determine when and if the store's state has indeed been\n         * refreshed. This approach was suggested by GitHub user @hotdogee.\n         * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\n         * @since 2.1.0\n         */\n        (store as any).restored = ((this.restoreState(this.key, this.storage)) as Promise<S>).then((savedState) => {\n          /**\n           * If in strict mode, do only via mutation\n           */\n          if (this.strictMode) {\n            store.commit('RESTORE_MUTATION', savedState)\n          } else {\n            store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\n          }\n          this.subscriber(store)((mutation: MutationPayload, state: S) => {\n            if (this.filter(mutation)) {\n              this._mutex.enqueue(\n                this.saveState(this.key, this.reducer(state), this.storage) as Promise<void>\n              )\n            }\n          })\n          this.subscribed = true\n        })\n      }\n    } else {\n\n      /**\n       * Sync {@link #VuexPersistence.restoreState} implementation\n       * @type {((key: string, storage?: Storage) =>\n       *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\n       */\n      this.restoreState = (\n        (options.restoreState != null)\n          ? options.restoreState\n          : ((key: string, storage: Storage) => {\n            const value = (storage).getItem(key)\n            if (typeof value === 'string') {// If string, parse, or else, just return\n              return (\n                this.supportCircular\n                  ? FlattedJSON.parse(value || '{}')\n                  : JSON.parse(value || '{}')\n              )\n            } else {\n              return (value || {})\n            }\n          })\n      )\n\n      /**\n       * Sync {@link #VuexPersistence.saveState} implementation\n       * @type {((key: string, state: {}, storage?: Storage) =>\n       *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\n       */\n      this.saveState = (\n        (options.saveState != null)\n          ? options.saveState\n          : ((key: string, state: {}, storage: Storage) =>\n            (storage).setItem(\n              key, // Second argument is state _object_ if localforage, stringified otherwise\n              (\n                this.supportCircular\n                  ? FlattedJSON.stringify(state) as any\n                  : JSON.stringify(state) as any\n              )\n            )\n          )\n      )\n\n      /**\n       * Sync version of plugin\n       * @param {Store<S>} store\n       */\n      this.plugin = (store: Store<S>) => {\n        const savedState = this.restoreState(this.key, this.storage) as S\n\n        if (this.strictMode) {\n          store.commit('RESTORE_MUTATION', savedState)\n        } else {\n          store.replaceState(merge(store.state, savedState || {}, this.mergeOption) as S)\n        }\n\n        this.subscriber(store)((mutation: MutationPayload, state: S) => {\n          if (this.filter(mutation)) {\n            this.saveState(this.key, this.reducer(state), this.storage)\n          }\n        })\n\n        this.subscribed = true\n      }\n    }\n  }\n\n  /**\n   * Creates a subscriber on the store. automatically is used\n   * when this is used a vuex plugin. Not for manual usage.\n   * @param store\n   */\n  private subscriber = (store: Store<S>) =>\n    (handler: (mutation: MutationPayload, state: S) => any) => store.subscribe(handler)\n}\n\nexport {\n  MockStorage, AsyncStorage, PersistOptions\n}\n\nexport default VuexPersistence\n"]},"metadata":{},"sourceType":"module"}